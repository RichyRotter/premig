#!/bin/bash

export ws_user=$1
export mail_to=$2
export ws_nr=$3

export currrent_user=$(whoami)
export rootDir="${HOME}/${ws_nr}/premigration"

# Colors
RED="\033[0;31m"
GREEN="\033[0;32m"
CYAN="\033[0;36m"
YELLOW="\033[1;33m"
NC="\033[0m"

cleanup() {

	printf "\e[?25h"

	echo
	#clear
	if [ "$current_user" == "premig" ]; then

		if [ "$trace_actions" == "true" ]; then

			echo "menu logout-----------------------------------" >>$trace_file
			echo $(date) >>$trace_file
			echo $SSH_CONNECTION >>$trace_file

		fi
	fi
	exit
}

run_sqlplus() {
	local sqlc="$1"
	local sqlf="$2"
	export sqlres=""

	sqlerr=0
	sqlres=$(
		sqlplus -s /@mondbp_mig <<EOF
     set heading off feedback off pagesize 0 
     set verify off linesize 32767 trims on termout on
     sta $sqlf;
     commit;
     exit;
EOF
	)
	if [ $(echo $sqlres | grep -i "ora-" | wc -l) -gt 0 ]; then
		sqlerr=1
		echo "sqlerr ... please verf code $sqlc"
		sleep 3
	fi
}

function set_current_cluster() {

	local sqlf="$rootDir/tmp/curcl.$$"

	cat <<EOF >$sqlf
	SELECT
    to_number(substr("MODERNEX Migration Cluster",9,2)) as cl
FROM (
    SELECT
        "MODERNEX Migration Cluster",
        "MODERNEX Migration Cluster Start Date"
    FROM
        masterdata.modernex_mig_cluster
    WHERE
        "MODERNEX Migration Cluster" LIKE 'Cl%'
        AND SYSDATE BETWEEN "MODERNEX Migration Cluster Start Date" AND "MODERNEX Migration Cluster End Date"
    ORDER BY
        "MODERNEX Migration Cluster Start Date" DESC
)
WHERE ROWNUM = 1;
EOF

	run_sqlplus "set_cluster" $sqlf

	export run_cluster=$(echo $sqlres | tr -d " ")

	echo
	echo "Set cluster to Cluster $run_cluster"
	sleep 2

}

function check_ws() {

	local rdir=$1
	local wsnr=$2
	local d1 cwsnr
	d1=$(dirname $rdir)
	cwsnr=$(basename $d1)

	if [ ! -d $rdir ] || [ $cwsnr -ne $wsnr ]; then
		echo "internal eror - wong ws assigment - exiting!"
		sleep 5
		exit 2
	fi
}

create_new_workspace() {

	local ws_user=$1
	local ws_nr=$2

	ws_error() {
		local ret=$1
		local etxt=$2

		if [ $ret -ne 0 ]; then
			echo "ws creation int. error: ${etxt}"
			sleep 5
			cleanup
		fi
	}

	mkdir -p ${HOME}/${ws_nr}/premigration
	ws_error $? "mkdir"
	cd ${HOME}/${ws_nr}/premigration
	cp ${HOME}/latest/premigration.env .
	ws_error $? "migenv"

	for d in tmp/tmp results/tufin results/tmp mailbox/tosend mailbox/tmp mailbox/sent dialog/tmp cpat/tmp cpat/instant_runs configfiles/tufin configfiles/tmp configfiles/seps_wallet configfiles/psrcnfs configfiles/poggsrc configfiles/ocinfs configfiles/dbinfos; do
		mkdir -p ./$d
		ws_error $? "mkdir $d"
	done

	find ${HOME}/latest/configfiles -maxdepth 1 -type f -exec cp -t ./configfiles {} +
	ws_error $? "conf"

	for l in oracle scripts sqls cpat25.2; do
		ln -s ${HOME}/latest/$l ./$l
		ws_error $? "lnk $l"
	done

	cd ${HOME}/${ws_nr}/premigration/scripts
	ws_error $? "goto new env"

	$rootDir/premigration.env
	echo "ws created	..."
	sleep 3
}

assign_cpat_selection() {
	local dbprimkey="$1"
	local schemafile="$2" # adjust if needed
	local DMP_SHARED_SELECTED=""
	local input

	if [[ ! -f "$schemafile" ]]; then
		echo "Schema file not found: $schemafile"
		sleep 2
		return
	fi

	echo
	echo "Available Schemas:"
	echo "------------------"

	DMP_SHARED_SELECTED=$(gum choose --output-delimiter=" " --no-limit --height=15 <$schemafile)

	echo
	echo "Selected schemas: $DMP_SHARED_SELECTED"

	gum confirm "confirm? " || return 1

	echo "Storing in CMDB..."
	./fetch_cmdb_data.sh update_cpat "$dbprimkey" "$DMP_SHARED_SELECTED"
	./fetch_cmdb_data.sh appinfos

	echo
	echo "Done."
	sleep 2
}

load_app_data() {
	local pk="$1"

	$rootDir/scripts/fetch_cmdb_data.sh appinfos_pk $pk $rootDir/tmp/${pk}_app_data.csv

	if [ $(cat $rootDir/tmp/${pk}_app_data.csv | grep $pk | wc -l) -ne 1 ]; then
		echo "Error loading app data for pk=$pk"
		exit 1
	fi

	dbmp_app_name=""
	selected_line=$(cat $rootDir/tmp/${pk}_app_data.csv | grep $pk)
	if [[ -z "$selected_line" ]]; then
		echo "Error loading app data for pk=$pk - line rror"
		sleep 3
		return
	else
		IFS='|' read -r \
			dbmp_target_platform dbmp_target_name dpmp_target_migr_methode \
			dbmp_test_tns_alias dbmp_oracle_db dbmp_env dbmp_dataclass dbmp_vnet \
			dbmp_app_name DBMP_ENV_ORIG DBMP_SHARED dbmp_target_tns_alias dbmp_migcluster \
			dbmp_primkey dbmp_target_env dbmp_nfs_ip dbmp_nfs_name dbmp_nfs_share BMP_NFS_MP dns_name src_ip AS csv_output <<<"$selected_line"

	fi
}

change_assign_nfs() {
	#############
	local dbpk=$1

	load_app_data $dbpk

	if [ "X$dbmp_app_name" != "X" ]; then

		echo " "
		echo "Change NFS Server assignment for application $dbmp_app_name"
		echo " "
		echo "Current nfs server assigned: ${DBMP_NFS_IP:-<none>}"

		gum confirm $confirm_params \
			"go ahead and cheange?" || return

		fetch_nfs "SEL" $dbmp_primkey
	fi
}

change_cpat_schemas() {

	local cluster="$1"

	clear
	gum style --foreground=$AC_RED --background=$AC_BLACK \
		--border rounded --margin "1 2" --padding "1 3" \
		--align center --width 100 --bold \
		"Change CPAT Schemas to be analyzed for $appln"

	gum style --foreground=$AC_YELLOW --background=$AC_BLACK \
		--align left --width 150 --bold \
		--margin "1 2" --padding "1 3" \
		"currently assigned: $cpatinfo"
	#    select_one_appinfo2 $run_cluster $dbprimkey "N"

	update_cpat_selection "$dbprimkey" "$oracledb"
}

function fetch_nfs() {

	local selectnfs=$1
	local appkey=$2
	local nfskey=""

	./fetch_cmdb_data.sh select_nfs
	local inputFile="$rootDir/configfiles/deployed_nfs.env"
	local -A seen_ips # Assoziatives Array zum Verfolgen der bereits gesehenen IPs

	printf "%-3s %-40s %-5s %-6s %-25s %-15s %-10s\n" \
		"ID" "Name" "Art" "Plattf" "Export" "IP" "Reachable"
	printf "%s\n" "------------------------------------------------------------------------------------------------------------------------"

	while IFS=',' read -r id name art platform _env _conf export ip; do
		if [[ -z "${seen_ips[$ip]}" ]]; then
			seen_ips["$ip"]=1

			# Port 2049 prüfen – Timeout 1 Sekunde
			if nc -z -w 1 "$ip" 2049 2>/dev/null; then
				reachable="yes"
			else
				reachable="no"
			fi

			printf "%-3s %-40s %-5s %-6s %-25s %-15s %-10s\n" \
				"$id" "$name" "$art" "$platform" "$export" "$ip" "$reachable"
			total=$id
		fi
	done <"$inputFile"

	if [ "X$selectnfs" != "XSEL" ]; then
		return
	fi

	echo
	while true; do
		# Clear line and print current selection + prompt
		echo -e "Current selection: ${DBMP_NFS_IP:-<none>}"
		read -rp "Enter server number (q=quit, c=confirmi, r=remove? :" input
		#    IFS= read -r input </dev/tty

		if [[ "$input" == "q" ]]; then
			echo -e "\nAborted. No changes made."
			sleep 2
			return
		elif [[ "$input" == "c" ]]; then
			break
		elif [[ "$input" == "r" ]]; then
			echo "server will be removed"
			nfskey=0
			sleep 2
			break
		else
			num=$input
			if [[ "$num" =~ ^[0-9]+$ ]] && ((num >= 1 && num <= total)); then
				echo "sel $num"
				nfskey=$(awk "NR==$num" $rootDir/configfiles/deployed_nfs.env | awk -F',' '{print $1}')
				break
			else
				echo -ne "\rInvalid selection: $num                                                    \n"
			fi
			printf "\033[1A\033[1G"
			printf "                                                                                                                "
			printf "\033[1A\033[1G"
		fi
	done

	if [ "X$nfskey" != "X" ]; then
		echo "Storing in CMDB..."
		./fetch_cmdb_data.sh update_nfs "$appkey" "$nfskey"
		./fetch_cmdb_data.sh appinfos
	fi

}

update_cpat_selection() {
	local primkey="$1"
	local srcdb="$2"
	local dbinfoDir="$rootDir/configfiles/dbinfos"
	local src_tns="${2}_system"
	local src_connect="/@$src_tns"
	local schema_file="$rootDir/configfiles/dbinfos/${srcdb}_schemas.env"

	if [ $(cat $TNS_ADMIN/tnsnames.ora | grep "$src_tns" | wc -l) -lt 1 ]; then
		echo "connect to db $srcdb not defined - cannot read schemas"
		echo "read dbinfos has errors - schemafile "
		sleep 2
		return
	fi

	./fetch_cmdb_data.sh "src_schemas" "$srcdb" "$src_connect"

	if [ ! -f $schema_file ]; then
		echo "read dbinfos has errors - schemafile "
		sleep 2
		return
	fi

	assign_cpat_selection $primkey $schema_file

}

function select_schematas() {

	local app_in_scope=$1
	local cpfile=$2

	echo "not implemented yet..use func in main menu instead"
	gum input --placeholder="Press enter"
	return

}

run_cpat() {
	local clnr="$!"
	local selectedf="$rootDir/tmp/selcpat1.$$"
	local selectedf2="$rootDir/tmp/selcpat2.$$"
	local seldbs=""
	local anz_dbs=0
	local sqlf=$rootDir/tmp/sql_for_cpat.$$
	local dispf=$rootDir/tmp/choose.$$
	local cpatsw="$rootDir/configfiles/cpatsw.tar"
	local ldat=$(date +"%Y%m%d-%H%M%S")
	local running_cpats="$rootDir/configfiles/running_cpats.$ldat"
	local line=""
	local schematas_file="$rootDir/tmp/schematas.$$"

	clear
	mhead
	select_appinfo2 $run_cluster $read_only_N $read_cmdb_N $page $sel_multi_Y "noinput" "$selectedf"

	if [ $(wc -c <"$selectedf") -lt 10 ]; then
		echo "no dbs selected..."
		sleep 2
		return
	fi

	anz_dbs=$(cat $selectedf | wc -l)
	if [ $anz_dbs -eq 0 ]; then
		echo "no DBs selected..."
		sleep 2
		return
	fi

	clear
	mhead
	select_appinfo2 $run_cluster $read_only_Y $read_cmdb_N 1 $sel_multi_Y "$selectedf" "$selectedf2"

	echo
	gum confirm $confirm_params \
		"Run cpat for $anz_dbs dbs?" || return

	echo " "
	schematas="Y"
	gum confirm $confirm_params \
		"would you like to select schematas for some dbs?" || schematas="N"

	if [ "$schematas" == "Y" ]; then

		clear
		mhead
		select_appinfo2 $run_cluster $read_only_N $read_cmdb_N 1 $sel_multi_Y "$selectedf" "$selectedf2"

		for dbmp in $(cat $selectedf2 | cut -d "|" -f3); do
			odb=$(cat $selectedf2 | grep $dbmp | cut -d "|" -f6)
			echo "--------------------------------------"
			echo "select for $odb"
			update_cpat_selection $dbmp "$odb"
		done

	fi

	$rootDir/scripts/fetch_cmdb_data.sh cpatschematas $schematas_file
	dblinks="Y"

	gum confirm $confirm_params \
		"Want to create DB-link template as well?" || dblinks="N"

	clear
	mhead
	echo

	echo -e "$EC_YELLOW  ------------------------------------START--------------------------------------------------$NC"
	sleep 2

	for indx in $(seq 1 $anz_dbs); do
		#awhile read -r _nr _cluster odb  sip _odbpk  osid _rest; do

		line=$(awk "NR == $indx" $selectedf)
		odb=$(echo $line | cut -d "|" -f6)
		odp=$(echo $line | cut -d "|" -f3)

		srcdb="$odb"
		cpat_dir="$rootDir/cpat25.2"
		cpatResultDir="$rootDir/cpat/tmp/cpat$$"
		cpatFinalResultDir="$rootDir/cpat/results/cluster_${run_cluster}"

		mkdir -p $cpatResultDir $cpatFinalResultDir &>/dev/null

		cpatschemas=""
		schematas=$(cat $schematas_file | grep "^$odp" | head -1 | cut -d "|" -f2)

		if [ "X$schematas" != "X" ]; then
			cpatschemas="--schema $schematas"
		fi

		offstat="EERROR"
		onstat="EERROR"

			cat <<EOF > $rootDir/tmp/cpat.sh
		        {
                         cd $rootDir/scripts
                         source ../premigration.env
	                 export JAVA_TOOL_OPTIONS="-Doracle.net.wallet_location=(SOURCE=(METHOD=FILE)(METHOD_DATA=(DIRECTORY=$HOME/.orawallet)))"
                  	 export JAVA_TOOL_OPTIONS="\$JAVA_TOOL_OPTIONS -Doracle.net.tns_admin=$TNS_ADMIN"
             
                         gg=""
                         for stat in offline online; do
			    ${cpat_dir}/premigration.sh \\
				--connectstring "jdbc:oracle:thin:@${srcdb}_system" \\
				--targetcloud ATPS $cpatschemas \\
				--outfileprefix ${srcdb}_\$stat \\
				--analysisprops "${cpat_dir}/properties/premigration_advisor_analysis.properties" \\
				--reportformat html \\
				--migrationmethod DATAPUMP \$gg \\
				--outdir "$cpatResultDir" 
			    gg="GOLDENGATE"
		        done  
		        } &>$rootDir/tmp/cpat.out
EOF
                        chmod +x  $rootDir/tmp/cpat.sh
		        $rootDir/tmp/cpat.sh &
			prcid=$!
                        laufzeit=0
                        while kill -0 $prcid 2>/dev/null; do
                             sleep 5
                             laufzeit=$((laufzeit + 5))
                             printf "\r  cpat for %-22s lz: %4d sec " "${odb:0:20}" "$laufzeit"
		        done

			{	

			if [ -f "$cpatResultDir/${srcdb}_online_premigration_advisor_report.html" ]; then
				mv "$cpatResultDir/${srcdb}_online_premigration_advisor_report.html" $cpatFinalResultDir
				mv "$cpatResultDir/${srcdb}_online_premigration_*.log" $cpatFinalResultDir
				onstat="OK"
			fi

			if [ -f "$cpatResultDir/${srcdb}_offline_premigration_advisor_report.html" ]; then
				mv "$cpatResultDir/${srcdb}_offline_premigration_advisor_report.html" $cpatFinalResultDir
				mv "$cpatResultDir/${srcdb}_offline_premigration_*.log" $cpatFinalResultDir
				offstat="OK"
			fi

			dblstat="NOT REQ."
			if [ "$dblinks" == "Y" ]; then
				dblstat="ERROR"

				{
					sqlplus -s /@${srcdb}_system <<EOF
      set heading off feedback off pagesize 0
     set verify off linesize 32767 trims on termout on
 
       sta $rootDir/sqls/create_dblinks_template.sql
      
       exit;
EOF
				} >"$cpatResultDir/${srcdb}_dblink_template.txt"

				if [ -f "$cpatResultDir/${srcdb}_dblink_template.txt" ]; then
					mv "$cpatResultDir/${srcdb}_dblink_template.txt" $cpatFinalResultDir
					dblstat="OK"
				fi
			fi

			if [[ "$(dirname "$cpatResultDir")" == "$rootDir/tmp" && -d "$cpatResultDir" ]]; then
				rm -rf "$cpatResultDir"
			fi
		} &>$rootDir/tmp/cpat.out

		mv $rootDir/tmp/cpat.out $cpatFinalResultDir/zz${ldat}_cpatrun.log
                printf "\r  cpat for %-22s lz: %4d sec; Status OFF: %-6s ON: %-6s DBL: %-6s \n" "${odb:0:20}" "$laufzeit"  "$offstat" " $onstat" "$dblstat"
		cd $rootDir/scripts

	done

	echo -e "$EC_YELLOW  ------------------------------------FINISHED-----------------------------------------------$NC"
	gum input --placeholder "Press énter"

}

show_cluster_data() {
	local cluster_num="$1"
	local cluster="Cluster ${cluster_num}"
	local lines_per_page=30
	local file="$rootDir/configfiles/appinfos2.env"
	local read_cmdb_Y="Y"
	local read_cmdb_N="N"
	local read_only_Y="Y"
	local read_only_N="N"
	local page=1

	select_appinfo2 $cluster_num $read_only_Y $read_cmdb_Y $page
	local max_page=$mig_app_max_page

	while true; do
		echo -e "curnt pag# $GREEN$page$NC of $GREEN$max_page$NC Selected Line: $mig_app_num"
		echo
		echo -e "[h]elp, [f]orward, [b]ack, [c]hange Cpat Schemas, [a]ppl change-cluster, $RED[d]isplay details, [n]fs assign,$NC [q]uit ?"
		echo
		cmd=$(gum input --placeholder="command?")

		case "$cmd" in
		f | F)
			if ((page < max_page)); then
				((page++))
				select_appinfo2 $cluster_num $read_only_Y $read_cmdb_N $page
			else
				echo "Already on last page."
				sleep 1
			fi
			;;
		d | D)
			select_appinfo2 $cluster_num $read_only_N $read_cmdb_N $page
			if [ "X$mig_app_num" != "X" ]; then
				./zdm_premigration.sh -a $mig_app_num -r $run_cluster -t "000" -x skip
			fi
			sleep 2
			;;

		b | B)
			if ((page > 0)); then
				((page--))
				select_appinfo2 $cluster_num $read_only_Y $read_cmdb_N $page
			else
				echo "Already on first page."
				sleep 1
			fi
			;;
		a | A)
			select_appinfo2 $cluster_num $read_only_N $read_cmdb_N $page
			if [ "X$mig_app_num" != "X" ]; then
				change_cluster_assignment "$cluster" "$file" $mig_app_num
			fi
			;;
		c | C)
			select_appinfo2 $cluster_num $read_only_N $read_cmdb_N $page
			if [ "X$mig_app_num" != "X" ]; then
				change_cpat_schemas "$cluster" "$file" $mig_app_num
			fi
			;;
		n | N)
			change_assign_nfs "$cluster" "$file"
			set_displaydata
			;;
		m | M)
			fetch_migdata "$(echo $selected_line | cut -d "|" -f5)"
			set_displaydata
			;;
		h | H)
			echo "Help: Use 'f' to go forward, 'b' back, 'c' assign cpat schemas, 'q' to quit, etc."
			echo -e "$RED New Features:"
			echo -e "d ... display all relevant Migration Infos without running a test"
			echo -e "n ... assign an alternate NFS  Server to this Appliction - at your own risk $NC $CYAN"
			read -rp "Press Enter to continue..."
			echo -e " $NC"
			;;
		q | Q)
			break
			;;
		*)
			echo "Unknown command: $cmd"
			sleep 1
			;;
		esac
		./fetch_cmdb_data.sh appinfos2 $run_cluster
		select_appinfo2 $cluster_num $read_only_Y $read_cmdb_N $page
	done
}

function run_tests() {

	local applfile="$1"
	local testcases="$2"
	local jnr=$(date +"%Y%m%d%H%M%S")
	local cnt=0
	local appanz=$(wc -l <$applfile)

	# Farben definieren
	local fcolor=$'\033[0;31m' # rot für FAIL
	local ecolor=$'\033[0;36m' # gelb für EX
	local ocolor=$'\033[0;32m' # grün für OK
	local reset=$'\033[0m'     # zurücksetzen

	clear
	mhead

	echo
	echo "on Application:"
	echo
	select_appinfo2 $run_cluster "Y" "N" 1 "N" "$applfile" "$rootDir/tmp/nix"
	echo
	echo "Runing this Tests"
	cat $testcases
	echo
	gum confirm $confirm_params \
		"confirm?" || return

	tests_to_run=$(cat $testcases | cut -d',' -f1 | paste -sd' ' -)
	clear
	mhead

	for appl_pk in $(cat $applfile | cut -d "|" -f3); do
		let cnt=${cnt}+1

		app_name=$(cat $applfile | grep $appl_pk | cut -d "|" -f4 | tr " " "_")
		app_env=$(cat $applfile | grep $appl_pk | cut -d "|" -f5)

		senv="DTQC"
		if [ "$app_env" == "Production" ]; then
			senv="Prod"
		fi

		cd "$rootDir/scripts"
		printf "%-22s %-6s" "${app_name:0:20}" "$senv"

		"$rootDir/scripts/zdm_premigrationv2.sh" -l "$cnt" -j "$jnr" -r "$run_cluster" -n m -b "$appl_pk" -m "$mail_to" -t "$tests_to_run" &>/dev/null &
		prcid=$!

		laufzeit=0

		printf "\e[?25l"

		while kill -0 $prcid 2>/dev/null; do
			sleep 5
			laufzeit=$((laufzeit + 5))
			printf "\r%-22s %-6s job activ,    lz: %4d sec   " "${app_name:0:20}" "$senv" "$laufzeit"

			#	printf "\033[1A\033[1G"
			#	printf "\r%-30s %-10s" "$app_name" "$senv"
			#        } > $rootDir/tmp/$app_name.zdmout

			cd $rootDir/results/${jnr}_${app_name}.${senv} &>/dev/null
			if [ $? -ne 0 ]; then
				echo "no Results - no resultdir ${jnr}_${app_name}.${senv}"
				continue
			fi

			{
				results=$(ls -1 *.result 2>/dev/null)
				ret=$?
			} &>/dev/null

			if [ $ret -eq 0 ]; then
				for rfile in $results; do
					rnum=$(cut -d ";" -f 1 "$rfile" | tr -d " ")
					stat=$(cut -d ";" -f 2 "$rfile" | tr -d " ")
					#    echo "$rnum"

					no_results=""
					case "$stat" in
					"PASSED")
						color="$ocolor"
						label="OK"
						;;
					"EXCEPTION")
						color="$ecolor"
						label="EX"
						;;
					"--FAILED---")
						color="$fcolor"
						label="FAIL"
						;;
					*)
						color="$reset"
						label="$stat"
						;;
					esac

					printf "%s%-10s%s" "$color" "${rnum}:$label" "$reset"
				done
			else
				no_results="--NR--"
			fi
		done

		printf "\r%-22s %-6s job finished, lz: %4d sec  %s " "${app_name:0:20}" "$senv" "$laufzeit" "$no_results"
		printf "\e[?25h"

		echo ""

	done
	cd $rootDir/scripts

	read -p "<--press return-->"
}

list_jobresults() {

	fcolor=$'\033[0;33m'
	ecolor=$'\033[0;36m'
	reset=$'\033[0m'

	resultDir=${rootDir}/results

	if [[ -z "$resultDir" ]]; then
		echo "Error: resultdir (parameter 1) must be specified."
		echo "Usage: list_jobresults <resultdir>"
		return 1
	fi

	if [[ ! -d "$resultDir" ]]; then
		echo "Error: Directory '$resultDir' does not exist or is not a directory."
		return 1
	fi

	echo "Searching for job numbers in: $resultDir"

	# Find directory names starting with 20*, extract job numbers
	mapfile -t jobdirs < <(find "$resultDir" -maxdepth 1 -type d -printf "%f\n" | grep '^20' | cut -d_ -f1 | sort -u)

	if [[ ${#jobdirs[@]} -eq 0 ]]; then
		echo "No job numbers found."
		return 0
	fi

	echo ""
	echo "Found job numbers:"

	echo "" >$rootDir/tmp/brf$$
	{
		for i in "${!jobdirs[@]}"; do

			printf "%s\n" "${jobdirs[$i]}"
		done
	} >>$rootDir/tmp/brf$$

	echo ""

	selected_job=$(gum choose --output-delimiter=" " --height=15 <$rootDir/tmp/brf$$ | tr -d " ")

	echo "Selected job number: $selected_job"

	echo ""
	echo "Results:"
	resf="/tmp/result_$$"
	nrf="/tmp/nrf_$$"
	>$resf
	>$nrf

	curdir=$(pwd)

	# Farben definieren
	fcolor=$'\033[0;31m' # rot für FAIL
	ecolor=$'\033[0;36m' # gelb für EX
	ocolor=$'\033[0;32m' # grün für OK
	reset=$'\033[0m'     # zurücksetzen

	# Schleife für Result-Ordner
	for rdir in $(find "$resultDir" -maxdepth 1 -type d -name "${selected_job}_*"); do
		app_name=$(basename "$rdir")
		printf "%-60s" "$app_name" >>"$resf"
		cd "$rdir" || continue

		{
			results=$(ls -1 *.result 2>/dev/null)
			ret=$?
		} &>/dev/null

		if [ $ret -eq 0 ]; then
			for rfile in $results; do
				rnum=$(cut -d ";" -f 1 "$rfile" | tr -d " ")
				stat=$(cut -d ";" -f 2 "$rfile" | tr -d " ")
				echo "$rnum" >>"$nrf"

				case "$stat" in
				"PASSED")
					color="$ocolor"
					label="OK"
					;;
				"EXCEPTION")
					color="$ecolor"
					label="EX"
					;;
				"--FAILED---")
					color="$fcolor"
					label="FAIL"
					;;
				*)
					color="$reset"
					label="$stat"
					;;
				esac

				printf "%s%-10s%s" "$color" "${rnum}:$label" "$reset" >>"$resf"
			done
		else
			printf "%-25s" "No Results found" >>"$resf"
		fi

		echo "" >>"$resf"
	done

	cd $curdir
	cat $nrf | sort -u >nr$$
	mv nr$$ $nrf
	./fetch_cmdb_data.sh testcases

	echo " " >>$resf
	echo "Legend:" >>$resf
	for tnr in $(cat $nrf); do
		txt=$(cat $rootDir/configfiles/testcases.csv | grep "$tnr" | cut -d ":" -f 3)
		echo "$tnr ... $txt" >>$resf
	done
	cat $resf
}

disp_nfs() {

	local inputFile="$rootDir/configfiles/deployed_nfs.env"
	declare -A seen_ips

	if [ $cnt2 -gt 0 ]; then

		for i in $(seq 1 "$cnt2"); do
			printf "\033[1A\033[1G"
			cnt2=0
		done
		printf "\r"

	fi
	printf "%-3s %-35s %-5s %-6s %-20s %-15s %-10s %8s %10s %12s %12s\n" \
		"ID" "Name" "Art" "Plattf" "Export" "IP" "Reachable" "CPU%" "TPS" "KB read/s" "KB wr/s"

	printf "%s\n" "-----------------------------------------------------------------------------------------------------------------------------------------------------"

	#  printf "%-3s %-35s %-5s %-6s %-25s %-15s %-10s %-10s %-10s %-10s %-10s\n" \
	#      "ID" "Name" "Art" "Plattf" "Export" "IP" "Reachable" "cpu%" "TPS" "KB read/s" "KB wr/s"
	#  printf "%s\n" "--------------------------------------------------------------------------------------------------------------------------------------------------"

	local cnt=2
	while IFS=',' read -r id name art platform _env _conf export ip || [ -n "$id" ]; do
		ipsh=$ip$exprt
		[[ -z "${seen_ips[$ipsh]}" ]] || continue
		seen_ips["$ipsh"]=1

		mp="/mnt/nfs"
		[[ "$platform" == "ATPS" ]] && mp="/sa4zdmfs"

		if nc -z -w 1 "$ip" 2049 2>/dev/null; then
			reachable="yes"

			nuser="nfs"
			#      clname=$(echo $name | cut -d "-"  -f1)
			if [ "$(echo $name | cut -d'-' -f1)" == "clu1" ]; then
				nuser="opc"
			fi

			get_remote_stats "$ip" "$nuser" "$HOME/.ssh/oci_rsa" </dev/null
		else
			reachable="no"
			REMO
			TE_CPU_USAGE="n/a"
			REMOTE_TPS="n/a"
			REMOTE_RKBP="n/a"
			REMOTE_WKBP="n/a"
		fi

		# Function to format a value as MB if > 10000

		printf "%-3s %-35s %-5s %-6s %-20s %-15s %-10s %8s %10s %12s %12s\n" \
			"$id" "$name" "$art" "$platform" "$export" "$ip" "$reachable" \
			"$REMOTE_CPU_USAGE" "$REMOTE_TPS" "$REMOTE_RKBP" "$REMOTE_WKBP"

		#   printf "%-3s %-35s %-5s %-6s %-25s %-15s %-10s %-10s %-10s %-10s %-10s\n" \
		#      "$id" "$name" "$art" "$platform" "$export" "$ip" "$reachable" "$REMOTE_CPU_USAGE" "$REMOTE_TPS" "$REMOTE_RKBP" "$REMOTE_WKBP"
		((cnt++))
	done <"$inputFile"
	cnt2=$cnt
}

show_migdata_phase() {

	local fil=$1
	local log=$2

	dlne=$(cat $file2)
	hst=$(echo $dlne | awk '{print $3}')
	jnr=$(echo $dlne | awk '{print $4}')
	echo $dlne
	echo $hst
	sleep 5

	local file="$rootDir/configfiles/zdmmiginfos_ph.env"
	local file2="$rootDir/tmp/zdmmiginfos_ph.$$"

	./fetch_cmdb_data.sh migdbinfos_ph $hst $jnr

	mhead
	cat $fil
	echo

	gchoose_simple $file $file2 "|" "single"

}

fetch_migdata() {

	local file="$rootDir/configfiles/zdmmiginfos2.env"
	local file2="$rootDir/tmp/zdmmiginfos.$$"

	./fetch_cmdb_data.sh migdbinfos2

	while true; do
		mhead
		gchoose_simple $file $file2 "|" "single"

		#            read -rp "show log or phases ? ret=phases, l=log " cmd

		show_migdata_phase $file2 $cmd

		gum confirm || break
	done

}

fetch_srchost() {
	local cluster_num="$1"
	local cluster="Cluster ${cluster_num}"
	local lines_per_page=30
	local file="$rootDir/configfiles/appinfos.env"

	>$rootDir/tmp/ssh_to_check.txt
	# Header formatting
	local header_fmt="%-3s %-10s %-35s %-14s %-24s %-30s %-10s %-22s %-20s\n"
	local row_fmt="%-3s %-10s %-28s %-15s %-24s %-15s\n"

	# Fetch latest data
	./fetch_cmdb_data.sh appinfos

	cat $file | grep "|$cluster|" >/tmp/sc$$

	clear

	local row_fmt="%-3s %-10s %-35s %-25s %-15s %-10s %-10s %-10s %-19s ${c4}%-10s$NC"
	local hdr_fmt="%-3s %-10s %-35s %-25s %-15s %-10s %-10s %-10s %-19s %-10s"

	echo -e $YELLOW
	# echo "Total Apps: $total_lines  in Cluster: $cluster_num"
	printf "${hdr_fmt}\n" "Nr" "MigCl" "App_Name" "Oracle_DB" "IP Address" "ssh?" "sftp?" "tns?" "TargetDb" "t-tns"
	echo -e "------------------------------------------------------------------------------------------------------------------------------------------------- $NC "

	local start=$((page * lines_per_page))
	local end=$((start + lines_per_page - 1))
	((end >= total_lines)) && end=$((total_lines - 1))

	local cnt=0
	local cntpg=0

	dline() {

		f1=$(printf "%-3s" "$cnt")
		f2=$(printf "%-10s" "$cluster")
		f3=$(printf "%-35s" "$dbmp_app_name")
		f4=$(printf "%-25s" "$dbmp_oracle_db")
		f5=$(printf "%-15s" "$dbmp_ip")
		f6=$(printf "%-10s" "$ssh_to_src")
		f7=$(printf "%-10s" "$sftp_to_src")
		f8=$(printf "%-10s" "$tns_to_src")
		f9=$(printf "%-19s" "$dbmp_target_name")
		f10=$(printf "%-10s" "$tns_to_tgt")
		echo -e "${CYAN}$f1 $f2 $f3 $f4 $f5 ${c1}$f6 ${c2}$f7 ${c3}$f8$NC $f9 ${c4}$f10$NC"
		#printf "\033[1A\033[1G"
		#printf "                                                                                                           	"
		#printf "\033[1A\033[1G"
	}

	while IFS='|' read -r \
		dbmp_target_platform dbmp_target_name dpmp_target_migr_methode \
		dbmp_test_tns_alias dbmp_oracle_db dbmp_env dbmp_dataclass dbmp_vnet \
		dbmp_app_name DBMP_ENV_ORIG DBMP_SHARED dbmp_target_tns_alias dbmp_migcluster dbmp_primkey \
		dbmp_target_env DBMP_NFS_IP DBMP_NFS_NAME dbmp_nfs_share DBMP_NFS_MP dbmp_dns dbmp_ip; do

		let cnt=${cnt}+1
		let cntpg=${cntpg}+1

		ssh_to_src="---"
		c1=$CYAN
		tns_to_src="---"
		c2=$CYAN
		sftp_to_src="---"
		c3=$CYAN
		tns_to_tgt="---"
		c4=$CYAN

		dline
		printf "\033[1A\033[1G"
		#printf "\r${row_fmt}" "$cnt" "$cluster" "$dbmp_app_name" "$dbm_oracle_db" "$dbmp_ip" "$ssh_to_src" "$sftp_to_src" "$tns_to_src" "$dbmp_target_name" "$tns_to_tgt"

		ssh_to_src="ssh_OK "
		c1=$GREEN
		timeout 2 ssh "$dbmp_ip" "pwd" </dev/null &>/dev/null
		if [ $? -ne 0 ]; then
			ssh_to_src="--xx-- "
			c1=$RED
			echo "$dbmp_ip" >>$rootDir/tmp/ssh_to_check.txt
		fi

		dline
		printf "\033[1A\033[1G"
		#printf "\r${row_fmt}" "$cnt" "$cluster" "$dbmp_app_name" "$dbm_oracle_db" "$dbmp_ip" "$ssh_to_src" "$sftp_to_src" "$tns_to_src" "$dbmp_target_name" "$tns_to_tgt"

		sftp_to_src="sftp_OK "
		c2=$GREEN
		timeout 2 sftp "$dbmp_ip" <<EOF &>/dev/null
quit
EOF
		if [ $? -ne 0 ]; then
			sftp_to_src="--xx-- "
			c2=$RED
		fi
		dline
		printf "\033[1A\033[1G"
		#printf "\r${row_fmt}" "$cnt" "$cluster" "$dbmp_app_name" "$dbm_oracle_db" "$dbmp_ip" "$ssh_to_src" "$sftp_to_src" "$tns_to_src" "$dbmp_target_name" "$tns_to_tgt"

		tns_to_src="tns_OK"
		c3=$GREEN
		timeout 2 tnsping "${dbmp_oracle_db}_system" </dev/null &>/dev/null
		if [ $? -ne 0 ]; then
			tns_to_src="--xx-- "
			c3=$RED
		fi

		dline
		printf "\033[1A\033[1G"
		#printf "\r${row_fmt}" "$cnt" "$cluster" "$dbmp_app_name" "$dbm_oracle_db" "$dbmp_ip" "$ssh_to_src" "$sftp_to_src" "$tns_to_src" "$dbmp_target_name" "$tns_to_tgt"

		tns_to_tgt="tns_OK"
		c4=$GREEN
		timeout 2 tnsping "${dbmp_target_tns_alias}" </dev/null &>/dev/null
		if [ $? -ne 0 ]; then
			tns_to_tgt="--xx-- "
			c4=$RED
		fi

		dline
		#printf "\r${row_fmt}\n" "$cnt" "$cluster" "$dbmp_app_name" "$dbm_oracle_db" "$dbmp_ip" "$ssh_to_src" "$sftp_to_src" "$tns_to_src" "$dbmp_target_name" "$tns_to_tgt"

	done <"/tmp/sc$$"
	rm "/tmp/sc$$"

	echo
	read -rp "press <return> " cmd

}

###########################################
###########################################
# main
###########################################
###########################################

if [ "X$ws_user" == "X" ] ||
	[ "X$ws_nr" == "X" ] ||
	[ "X$mail_to" == "X" ]; then

	echo "u:$ws_user n:$ws_nr e:$mail_to"
	echo -e "$EC_RED Upps ... something went wrong ... internal error @ init $EC_NC"
	sleep 3
	exit 1
fi

if [ "$current_user" != "mig" ]; then
	trap cleanup EXIT INT TERM
fi
if [ ! -d $rootDir ]; then
	create_new_workspace $ws_user $ws_nr
	ws_status="created"
else
	check_ws $rootDir $ws_nr
	ws_status="re-assigned"
fi

cd $rootDir/scripts
source $rootDir/premigration.env
source ${rootDir}/scripts/utils_gum.sh
source $rootDir/scripts/utils_main_menu.sh
source $rootDir/scripts/utils_mail_cpats.sh

caller_ip=$(echo $SSH_CONNECTION | awk '{ print $1 }')
trace_actions="false"
current_user=$(whoami)
dayfile=$(date +"%Y%m%d")
trace_file="/tmp/premig_traces/${dayfile}_actions.txt"
trace_dir="/tmp/premig_traces"

trace_actions="false"
if [ "$current_user" == "premig" ]; then

	if [ $(echo $SSH_CONNECTION | grep "10.127.123.203" | wc -l) -eq 0 ]; then

		if [ ! -d $trace_dir ]; then
			mkdir $trace_dir
			chmod 777 $trace_dir
		fi

		echo "menu login------------------------------------" >>$trace_file
		echo $(date) >>$trace_file
		echo $SSH_CONNECTION >>$trace_file
		trace_actions="true"

	fi
fi

#select_migcluster
#export run_cluster=$mig_cluster_num
set_current_cluster
show_main_menu
exit 0
